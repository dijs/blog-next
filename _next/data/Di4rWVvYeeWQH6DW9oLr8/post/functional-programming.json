{"pageProps":{"metadata":{"published":true,"title":"Functional Programming","blurb":"Start writing better code with these tips","layout":"post","date":"Jan 31, 2016"},"content":"\nAs I learn more about programming through the years, I find it incredible how the techniques I have come to love are normally very old.\n\nI love math. Always have.\n\nMath inherently does not have extra state laying around. I believe that when we transform our application's state, nothing external of our transformation context should affect the resultant state.\n\n### What do I mean by this?\n\nHere is a simple example: *Let's create a function which computes the sum of a list of numbers.*\n\nHere is an example which uses extra dangerous state (**DON'T DO THIS!**):\n```js\n// This is the external data which\n// could be affected by other code\n// in this context\nlet sum = 0\nfunction computeSum (numbers) {\n  numbers.forEach(n => sum += n)\n}\ncomputeSum([1,2,3])\nconst result = sum\n```\n\nNow, a better example, using a more functional technique:\n\n```js\nconst bySum = (sum, n) => sum + n\n// This is safe from any\n// external code\nconst sum = numbers => numbers.reduce(bySum)\nconst result = sum([1,2,3])\n```\n\nWith functional programming, we can trust our code more. Functional code is more maintainable, predictable, doesn't mutate other code, can be reused, smaller, and sometimes more readable (depending on who is reading it).\n","slug":"functional-programming","index":22,"path":"/post/functional-programming"},"__N_SSG":true}